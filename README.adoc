ell
===
:compact-option:

'ell' is a modified subset of Scheme with added syntax sugar, incorporating
ideas from Perl, Tcl and Bourne shell.  The goal was to conceive a programming
language implementable with as little code as possible while still being
reasonably comfortable to use.

This package is an implementation of said language, meant to be self-contained,
portable and reusable.  Performance is specifically not an intent.

The project is currently in a "proof of concept" stage with many useful data
operations missing but I believe it won't be a problem to implement them as
needed for anyone interested.

Syntax
------
Owing to its Scheme heritage, 'ell' is homoiconic, that is a program can be
directly expressed using the language's data types.  There are only two of
those: the list and the string.  Any numerical conversions are made on an
as-needed basis.  Similarly, strings act like atoms/symbols when executed.

The parser, however, does a bunch of transformations:

 * `[a b c]` makes a call to `(list a b c)`;
 * `@var` is a shorthand for `(set var)`;
 * `{ code }` is the most complex one.  Each line within the curly braces is
   wrapped in parentheses, and the resulting list is quoted, so that it doesn't
   execute immediately.

As an example, consider the following snippet:

 print (if { eq? @var foo } {
     values 'Hello world\n'
 } else {
     values 'Error\n'
 })

which gets expanded to the following:

 ((print (if (quote ((eq? (set var) foo)))
             (quote ((values 'Hello world\n')))
             else
             (quote ((values 'Error\n'))))))

Observe that the whole program is enclosed in an implicit pair of `{}` and that
`quote` is a very powerful special form which can replace many others if needed.

For a slightly more realistic example have a look at 'greet.ell'.

Runtime
-------
All variables are put in a single global namespace with no further scoping.
Arguments to a block (which is a list of lists) must be assigned to variables
first using the `arg` special form, and that must happen before they get
overriden by execution of a different block.

When evaluating a command, the first argument is typically a string with its
name and it is resolved as if `set` was called on it.

The last expression in a block is the return value.

Special Forms
-------------
`quote [<arg>]...`

Returns the arguments without any evaluation.

`arg [<name>]...`

Assigns arguments to the current call in order to given names.
Names for which there are no values left are set to `[]`.

Standard library
----------------
The standard library interprets the empty list and the empty string as false
values, everything else is taken as true.

`set <name> [<value>]`

Retrieve or set a named variable.  The syntax sugar for retrieval is `@`.

`list [<item>]...`

Return a list made of given arguments.  The syntax sugar for lists is `[]`.

`values [<item>]...`

Return an arbitrary number of values.

`if <cond> <body> [elif <cond> <body>]... [else <body>]`

Conditional evaluation, strings evaluate to themselves.

`for <list> <body>`

Run the body for each element.

`break`

Abort the running loop.

`map <list> <body>`

Transform each element with the given function.

`filter <list> <body>`

Return a new list consisting of matching elements only.

`.. [<string>]...`

Concatenate strings.

`print [<item>]...`

Print all items in sequence--strings directly, lists as source code.

`system <command>`

Run a system command and return its return value.

`parse <program>`

Parse a program into a list of lists.

`try <body> <handler>`

Execute the body and pass any error to the handler instead of propagating it.

`throw <message>`

Throw an error.  Messages starting on an underscore don't generate backtraces.

`not <value>`

Return a boolean with the opposite truthiness.

`and [<body>]...`, `or [<body>]...`

Short-circuit evaluation, trying to return whatever the bodies result in.

`+`, `-`, `*`, `/`

Arithmetic operations on floating point numbers.

`=`, `<>`, `<`, `>`, `<=`, `>=`

Arithmetic comparisons on floating point numbers.

`eq?`, `ne?`, `lt?`, `gt?`, `le?`, `ge?`

Simple string comparisons.

Building and Running
--------------------
By default, running `make' will only build the interpreter:

 $ make
 $ ./interpreter greet.ell

Install development packages for GNU Readline to get a REPL for toying around:

 $ make repl
 $ ./repl

Possible Ways of Complicating
-----------------------------
 * variable scoping: the simplest is to set values in the nearest scope they
   can be found in but make `arg` an exception to that, just like in AWK
 * reference counting: currently all values are always copied as needed, which
   is good enough for all imaginable use cases, simpler and less error-prone

Contributing and Support
------------------------
Use this project's GitHub to report any bugs, request features, or submit pull
requests.  If you want to discuss this project, or maybe just hang out with
the developer, feel free to join me at irc://irc.janouch.name, channel #dev.

Bitcoin donations: 12r5uEWEgcHC46xd64tt3hHt9EUvYYDHe9

License
-------
'ell' is written by PÅ™emysl Janouch <p.janouch@gmail.com>.

You may use the software under the terms of the ISC license, the text of which
is included within the package, or, at your option, you may relicense the work
under the MIT or the Modified BSD License, as listed at the following site:

http://www.gnu.org/licenses/license-list.html
